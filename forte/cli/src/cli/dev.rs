use crate::server::{self, ServerConfig, ServerHandle};
use anyhow::{Context, Result};
use notify_debouncer_mini::{new_debouncer, notify::RecursiveMode};
use std::fs;
use std::net::{SocketAddr, TcpListener};
use std::path::{Path, PathBuf};
use std::process::Command;
use std::sync::mpsc::channel;
use std::time::Duration;

#[derive(Debug)]
pub struct DevOptions {
    pub project_dir: PathBuf,
    /// None means auto-select starting from 3000
    pub port: Option<u16>,
}

impl Default for DevOptions {
    fn default() -> Self {
        Self {
            project_dir: PathBuf::from("."),
            port: None,
        }
    }
}

fn is_port_available(port: u16) -> bool {
    let addr = SocketAddr::from(([127, 0, 0, 1], port));
    TcpListener::bind(addr).is_ok()
}

fn find_available_port(start: u16) -> Option<u16> {
    (start..=65535).find(|&port| is_port_available(port))
}

fn run_codegen(project_dir: &Path) -> Result<()> {
    let rs_dir = project_dir.join("rs");

    let forte_rs_to_ts_dir = Path::new(env!("CARGO_MANIFEST_DIR"))
        .parent()
        .expect("Failed to get parent of CARGO_MANIFEST_DIR")
        .join("forte-rs-to-ts");

    println!("[codegen] Running forte-rs-to-ts...");
    let status = Command::new("cargo")
        .arg("run")
        .arg("--release")
        .arg("--")
        .arg(&rs_dir)
        .current_dir(&forte_rs_to_ts_dir)
        .env_remove("RUSTUP_TOOLCHAIN")
        .status()
        .context("Failed to run forte-rs-to-ts. Is it installed?")?;

    if !status.success() {
        anyhow::bail!("forte-rs-to-ts failed with status: {}", status);
    }

    generate_frontend_routes(project_dir)?;

    Ok(())
}

#[derive(Debug)]
struct RouteInfo {
    path: String,
    fe_page_path: String,
}

fn generate_frontend_routes(project_dir: &Path) -> Result<()> {
    let pages_dir = project_dir.join("rs/src/pages");
    let fe_src_dir = project_dir.join("fe/src");

    if !pages_dir.exists() {
        return Ok(());
    }

    println!("[codegen] Generating frontend routes...");

    let mut routes = Vec::new();
    scan_pages_dir(&pages_dir, &pages_dir, &mut routes)?;

    routes.sort_by(|a, b| {
        let a_dynamic = a.path.contains(':');
        let b_dynamic = b.path.contains(':');
        if a_dynamic != b_dynamic {
            return a_dynamic.cmp(&b_dynamic);
        }
        a.path.cmp(&b.path)
    });

    let mut output = String::new();
    output.push_str("// Auto-generated by forte dev\n\n");
    output.push_str("export const routes: Array<{ path: string; component: () => Promise<{ default: (props: any) => any }>; schema: () => Promise<{ PropsSchema: any }> }> = [\n");

    for route in &routes {
        // Replace only the trailing "/page" with "/.props"
        let fe_props_path = route.fe_page_path
            .strip_suffix("/page")
            .map(|s| format!("{}/.props", s))
            .unwrap_or_else(|| route.fe_page_path.clone());
        output.push_str(&format!(
            "  {{ path: \"{}\", component: () => import(\"{}\"), schema: () => import(\"{}\") }},\n",
            route.path, route.fe_page_path, fe_props_path
        ));
    }

    output.push_str("];\n");

    fs::write(fe_src_dir.join("routes.generated.ts"), output)?;

    println!("[codegen] Generated {} route(s)", routes.len());

    Ok(())
}

fn scan_pages_dir(base_dir: &Path, current_dir: &Path, routes: &mut Vec<RouteInfo>) -> Result<()> {
    for entry in fs::read_dir(current_dir)? {
        let entry = entry?;
        let path = entry.path();

        if path.is_dir() {
            scan_pages_dir(base_dir, &path, routes)?;
        } else if path.extension().is_some_and(|ext| ext == "rs")
            && has_handler_function(&path)?
            && let Some(route) = path_to_route(base_dir, &path)
        {
            routes.push(route);
        }
    }
    Ok(())
}

fn has_handler_function(path: &Path) -> Result<bool> {
    let content = fs::read_to_string(path)?;
    Ok(content.contains("pub async fn handler"))
}

fn path_to_route(base_dir: &Path, file_path: &Path) -> Option<RouteInfo> {
    let relative = file_path.strip_prefix(base_dir).ok()?;
    let relative_str = relative.to_string_lossy();

    let mut route_path = relative_str
        .trim_end_matches(".rs")
        .trim_end_matches("/mod")
        .replace('\\', "/");

    if route_path == "index" || route_path.is_empty() {
        route_path = "/".to_string();
    } else {
        route_path = route_path
            .replace("/index", "")
            .replace("[", ":")
            .replace("]", "");
        if !route_path.starts_with('/') {
            route_path = format!("/{}", route_path);
        }
    }

    let fe_page_path = build_fe_page_path(&route_path);

    Some(RouteInfo {
        path: route_path,
        fe_page_path,
    })
}

fn build_fe_page_path(route_path: &str) -> String {
    if route_path == "/" {
        "./pages/index/page".to_string()
    } else {
        let path = route_path
            .replace(":", "[")
            .split('/')
            .filter(|s| !s.is_empty())
            .map(|s| {
                if s.starts_with('[') {
                    format!("{}]", s)
                } else {
                    s.to_string()
                }
            })
            .collect::<Vec<_>>()
            .join("/");
        format!("./pages/{}/page", path)
    }
}

fn build_backend(project_dir: &Path) -> Result<()> {
    println!("[build] Building backend...");
    let status = Command::new("cargo")
        .arg("build")
        .arg("--release")
        .arg("--target")
        .arg("wasm32-wasip2")
        .arg("-p")
        .arg("backend")
        .current_dir(project_dir)
        .status()
        .context("Failed to run cargo build")?;

    if !status.success() {
        anyhow::bail!("cargo build failed with status: {}", status);
    }

    Ok(())
}

#[allow(dead_code)]
fn build_server_js(project_dir: &Path) -> Result<()> {
    let fe_dir = project_dir.join("fe");

    println!("[build] Building server.js for SSR (dev mode)...");
    let status = Command::new("npx")
        .arg("vite")
        .arg("build")
        .arg("--ssr")
        .arg("src/server.tsx")
        .arg("--outDir")
        .arg("dist")
        .arg("--mode")
        .arg("development")
        .current_dir(&fe_dir)
        .status()
        .context("Failed to build server.js")?;

    if !status.success() {
        anyhow::bail!("vite build --ssr failed with status: {}", status);
    }

    Ok(())
}

pub async fn run(options: DevOptions) -> Result<()> {
    let project_dir = options.project_dir.canonicalize()?;

    let port = match options.port {
        Some(p) => {
            if !is_port_available(p) {
                eprintln!("Error: Port {} is already in use", p);
                std::process::exit(1);
            }
            p
        }
        None => {
            let p = find_available_port(3000)
                .ok_or_else(|| anyhow::anyhow!("No available port found starting from 3000"))?;
            if p != 3000 {
                println!("Port 3000 in use, using port {} instead", p);
            }
            p
        }
    };

    println!("Starting Forte dev server...");
    println!("Project directory: {}", project_dir.display());

    run_codegen(&project_dir)?;
    build_backend(&project_dir)?;

    let backend_path = project_dir
        .join("target/wasm32-wasip2/release/backend.wasm")
        .to_string_lossy()
        .to_string();

    let frontend_path = project_dir
        .join("fe/dist/server.js")
        .to_string_lossy()
        .to_string();

    let public_dir = project_dir.join("fe/public");
    let fe_dir = project_dir.join("fe");

    let config = ServerConfig {
        port,
        backend_path,
        frontend_path,
        public_dir,
        fe_dir,
        dev_mode: true,
    };

    let handle = server::run(config).await?;

    run_watch_loop(&project_dir, handle).await
}

async fn run_watch_loop(project_dir: &Path, handle: ServerHandle) -> Result<()> {
    let (tx, rx) = channel();

    let mut debouncer = new_debouncer(Duration::from_millis(500), tx)?;

    let rs_dir = project_dir.join("rs/src");

    debouncer
        .watcher()
        .watch(&rs_dir, RecursiveMode::Recursive)?;

    println!("[watch] Watching for backend changes in rs/src...");
    println!("[watch] Frontend HMR handled by Vite");

    let mut is_rebuilding = false;

    loop {
        match rx.recv() {
            Ok(Ok(events)) => {
                // Skip events during rebuild (cargo check touches file metadata)
                if is_rebuilding {
                    continue;
                }

                let backend_changed = events.iter().any(|e| {
                    e.path.starts_with(&rs_dir)
                        && e.path.extension().is_some_and(|ext| ext == "rs")
                        && !e.path.ends_with("route_generated.rs")
                });

                if backend_changed {
                    println!();
                    println!("[watch] Backend changes detected, rebuilding...");

                    is_rebuilding = true;
                    let result = rebuild_backend(project_dir, &handle).await;

                    // Drain any pending events that occurred during rebuild
                    while rx.try_recv().is_ok() {}

                    is_rebuilding = false;

                    if let Err(e) = result {
                        eprintln!("[watch] Backend rebuild failed: {}", e);
                    } else {
                        handle.hmr.send_reload();
                        println!("[watch] Sent reload signal to browser");
                    }

                    println!("[watch] Ready for requests");
                }
            }
            Ok(Err(error)) => {
                eprintln!("[watch] Error: {:?}", error);
            }
            Err(e) => {
                eprintln!("[watch] Channel error: {:?}", e);
                break;
            }
        }
    }

    Ok(())
}

async fn rebuild_backend(project_dir: &Path, handle: &ServerHandle) -> Result<()> {
    println!("[rebuild] Running codegen...");
    run_codegen(project_dir)?;

    println!("[rebuild] Building backend...");
    build_backend(project_dir)?;

    handle.cache.invalidate("backend").await;
    println!("[rebuild] Backend cache invalidated");

    Ok(())
}
