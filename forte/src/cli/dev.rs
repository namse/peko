use anyhow::{Context, Result};
use notify_debouncer_mini::{new_debouncer, notify::RecursiveMode};
use std::fs;
use std::net::{SocketAddr, TcpListener};
use std::path::{Path, PathBuf};
use std::process::Command;
use std::sync::mpsc::channel;
use std::time::Duration;

use crate::server::{self, ServerConfig, ServerHandle};

#[derive(Debug)]
pub struct DevOptions {
    pub project_dir: PathBuf,
    /// None means auto-select starting from 3000
    pub port: Option<u16>,
}

impl Default for DevOptions {
    fn default() -> Self {
        Self {
            project_dir: PathBuf::from("."),
            port: None,
        }
    }
}

fn is_port_available(port: u16) -> bool {
    let addr = SocketAddr::from(([127, 0, 0, 1], port));
    TcpListener::bind(addr).is_ok()
}

fn find_available_port(start: u16) -> Option<u16> {
    (start..=65535).find(|&port| is_port_available(port))
}

fn run_codegen(project_dir: &Path) -> Result<()> {
    let rs_dir = project_dir.join("rs");

    let forte_rs_to_ts_dir = Path::new(env!("CARGO_MANIFEST_DIR"))
        .parent()
        .expect("Failed to get parent of CARGO_MANIFEST_DIR")
        .join("forte-rs-to-ts");

    println!("[codegen] Running forte-rs-to-ts...");
    let status = Command::new("cargo")
        .arg("run")
        .arg("--release")
        .arg("--")
        .arg(&rs_dir)
        .current_dir(&forte_rs_to_ts_dir)
        .env_remove("RUSTUP_TOOLCHAIN")
        .status()
        .context("Failed to run forte-rs-to-ts. Is it installed?")?;

    if !status.success() {
        anyhow::bail!("forte-rs-to-ts failed with status: {}", status);
    }

    generate_frontend_routes(project_dir)?;

    Ok(())
}

#[derive(Debug)]
struct RouteInfo {
    path: String,
    fe_page_path: String,
}

fn generate_frontend_routes(project_dir: &Path) -> Result<()> {
    let pages_dir = project_dir.join("rs/src/pages");
    let fe_src_dir = project_dir.join("fe/src");

    if !pages_dir.exists() {
        return Ok(());
    }

    println!("[codegen] Generating frontend routes...");

    let mut routes = Vec::new();
    scan_pages_dir(&pages_dir, &pages_dir, &mut routes)?;

    routes.sort_by(|a, b| {
        let a_dynamic = a.path.contains(':');
        let b_dynamic = b.path.contains(':');
        if a_dynamic != b_dynamic {
            return a_dynamic.cmp(&b_dynamic);
        }
        a.path.cmp(&b.path)
    });

    let mut output = String::new();
    output.push_str("// Auto-generated by forte dev\n\n");
    output.push_str("export const routes: Array<{ path: string; component: () => Promise<{ default: (props: any) => any }> }> = [\n");

    for route in &routes {
        output.push_str(&format!(
            "  {{ path: \"{}\", component: () => import(\"{}\") }},\n",
            route.path, route.fe_page_path
        ));
    }

    output.push_str("];\n");

    fs::write(fe_src_dir.join("routes.generated.ts"), output)?;

    println!("[codegen] Generated {} route(s)", routes.len());

    Ok(())
}

fn scan_pages_dir(base_dir: &Path, current_dir: &Path, routes: &mut Vec<RouteInfo>) -> Result<()> {
    for entry in fs::read_dir(current_dir)? {
        let entry = entry?;
        let path = entry.path();

        if path.is_dir() {
            scan_pages_dir(base_dir, &path, routes)?;
        } else if path.extension().is_some_and(|ext| ext == "rs")
            && has_handler_function(&path)?
            && let Some(route) = path_to_route(base_dir, &path)
        {
            routes.push(route);
        }
    }
    Ok(())
}

fn has_handler_function(path: &Path) -> Result<bool> {
    let content = fs::read_to_string(path)?;
    Ok(content.contains("pub async fn handler"))
}

fn path_to_route(base_dir: &Path, file_path: &Path) -> Option<RouteInfo> {
    let relative = file_path.strip_prefix(base_dir).ok()?;
    let relative_str = relative.to_string_lossy();

    let mut route_path = relative_str
        .trim_end_matches(".rs")
        .trim_end_matches("/mod")
        .replace('\\', "/");

    if route_path == "index" || route_path.is_empty() {
        route_path = "/".to_string();
    } else {
        route_path = route_path
            .replace("/index", "")
            .replace("[", ":")
            .replace("]", "");
        if !route_path.starts_with('/') {
            route_path = format!("/{}", route_path);
        }
    }

    let fe_page_path = build_fe_page_path(&route_path);

    Some(RouteInfo {
        path: route_path,
        fe_page_path,
    })
}

fn build_fe_page_path(route_path: &str) -> String {
    if route_path == "/" {
        "./pages/index/page".to_string()
    } else {
        let path = route_path
            .replace(":", "[")
            .split('/')
            .filter(|s| !s.is_empty())
            .map(|s| if s.starts_with('[') { format!("{}]", s) } else { s.to_string() })
            .collect::<Vec<_>>()
            .join("/");
        format!("./pages/{}/page", path)
    }
}

fn build_backend(project_dir: &Path) -> Result<()> {
    let rs_dir = project_dir.join("rs");

    println!("[build] Building backend...");
    let status = Command::new("cargo")
        .arg("build")
        .arg("--release")
        .current_dir(&rs_dir)
        .status()
        .context("Failed to run cargo build")?;

    if !status.success() {
        anyhow::bail!("cargo build failed with status: {}", status);
    }

    Ok(())
}

fn build_frontend(project_dir: &Path) -> Result<()> {
    let fe_dir = project_dir.join("fe");

    println!("[build] Building frontend...");
    let status = Command::new("npm")
        .arg("run")
        .arg("build")
        .current_dir(&fe_dir)
        .status()
        .context("Failed to run npm run build")?;

    if !status.success() {
        anyhow::bail!("npm run build failed with status: {}", status);
    }

    let client_src = fe_dir.join("dist/client.js");
    let client_dst = fe_dir.join("public/client.js");
    if client_src.exists() {
        std::fs::copy(&client_src, &client_dst)?;
        println!("[build] Copied client.js to public/");
    }

    Ok(())
}

pub async fn run(options: DevOptions) -> Result<()> {
    let project_dir = options.project_dir.canonicalize()?;

    let port = match options.port {
        Some(p) => {
            if !is_port_available(p) {
                eprintln!("Error: Port {} is already in use", p);
                std::process::exit(1);
            }
            p
        }
        None => {
            let p = find_available_port(3000)
                .ok_or_else(|| anyhow::anyhow!("No available port found starting from 3000"))?;
            if p != 3000 {
                println!("Port 3000 in use, using port {} instead", p);
            }
            p
        }
    };

    println!("Starting Forte dev server...");
    println!("Project directory: {}", project_dir.display());

    run_codegen(&project_dir)?;
    build_backend(&project_dir)?;
    build_frontend(&project_dir)?;

    let backend_path = project_dir
        .join("rs/target/wasm32-wasip2/release/backend.wasm")
        .to_string_lossy()
        .to_string();

    let frontend_path = project_dir
        .join("fe/dist/server.js")
        .to_string_lossy()
        .to_string();

    let public_dir = project_dir.join("fe/public");

    let config = ServerConfig {
        port,
        backend_path,
        frontend_path,
        public_dir,
    };

    let handle = server::run(config).await?;

    run_watch_loop(&project_dir, handle).await
}

async fn run_watch_loop(project_dir: &Path, handle: ServerHandle) -> Result<()> {
    let (tx, rx) = channel();

    let mut debouncer = new_debouncer(Duration::from_millis(500), tx)?;

    let rs_dir = project_dir.join("rs/src");
    let fe_dir = project_dir.join("fe/src");

    debouncer.watcher().watch(&rs_dir, RecursiveMode::Recursive)?;
    debouncer.watcher().watch(&fe_dir, RecursiveMode::Recursive)?;

    println!("[watch] Watching for changes in rs/src and fe/src...");

    loop {
        match rx.recv() {
            Ok(Ok(events)) => {
                let mut backend_changed = false;
                let mut frontend_changed = false;

                for event in events {
                    let path = &event.path;
                    if path.starts_with(&rs_dir) {
                        backend_changed = true;
                    } else if path.starts_with(&fe_dir) {
                        frontend_changed = true;
                    }
                }

                if backend_changed || frontend_changed {
                    println!();
                    println!("[watch] Changes detected, rebuilding...");

                    let mut backend_ok = true;
                    let mut frontend_ok = true;

                    if backend_changed
                        && let Err(e) = rebuild_backend(project_dir, &handle).await
                    {
                        eprintln!("[watch] Backend rebuild failed: {}", e);
                        backend_ok = false;
                    }

                    if frontend_changed
                        && let Err(e) = rebuild_frontend(project_dir, &handle).await
                    {
                        eprintln!("[watch] Frontend rebuild failed: {}", e);
                        frontend_ok = false;
                    }

                    if backend_ok && frontend_ok {
                        handle.hmr.send_reload();
                        println!("[watch] Sent reload signal to browser");
                    }

                    println!("[watch] Ready for requests");
                }
            }
            Ok(Err(error)) => {
                eprintln!("[watch] Error: {:?}", error);
            }
            Err(e) => {
                eprintln!("[watch] Channel error: {:?}", e);
                break;
            }
        }
    }

    Ok(())
}

async fn rebuild_backend(project_dir: &Path, handle: &ServerHandle) -> Result<()> {
    println!("[rebuild] Running codegen...");
    run_codegen(project_dir)?;

    println!("[rebuild] Building backend...");
    build_backend(project_dir)?;

    handle.cache.invalidate("backend").await;
    println!("[rebuild] Backend cache invalidated");

    Ok(())
}

async fn rebuild_frontend(project_dir: &Path, handle: &ServerHandle) -> Result<()> {
    println!("[rebuild] Running codegen...");
    run_codegen(project_dir)?;

    println!("[rebuild] Building frontend...");
    build_frontend(project_dir)?;

    handle.cache.invalidate("frontend").await;
    println!("[rebuild] Frontend cache invalidated");

    Ok(())
}
