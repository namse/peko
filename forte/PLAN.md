# Forte CLI 구현 계획

## 개요

Forte는 Rust 백엔드 + TypeScript/React 프론트엔드를 통합하는 풀스택 프레임워크입니다.
이 문서는 Forte CLI 도구 구현 계획을 정리합니다.

## 현재 상태

### 기존 구성요소

| 프로젝트 | 역할 | 상태 |
|----------|------|------|
| `forte/` | SSR 서버 오케스트레이션 | PoC 완료 |
| `forte-manual/` | 수동 생성된 예제 앱 | PoC 완료 |
| `forte-rs-to-ts/` | Rust → TypeScript 타입 생성 | 완료 |
| `forte-json/` | 스트리밍 JSON 직렬화 | 완료 |
| `fn0/` | WASM/JS 실행 엔진 | 완료 |
| `ski/` | JavaScript 런타임 (Deno core) | 완료 |

### 코드 생성 역할 분담

| 생성 대상 | 담당 | 실행 시점 |
|-----------|------|-----------|
| 백엔드 라우트 (`route_generated.rs`) | `build.rs` | `cargo build` |
| Props 타입 (`.props.ts`) | CLI → `forte-rs-to-ts` 호출 | `forte dev` |
| 프론트엔드 라우터 (`routes.generated.ts`) | CLI | `forte dev` |
| Action 타입 + 클라이언트 (`forte:actions`) | CLI | `forte dev` |

- 백엔드 개발자: `cargo build`만으로 작업 가능
- 프론트엔드 개발자: `forte dev`로 타입 + 라우터 동기화

---

## CLI 명령어 구조

```
forte init <project-name>     # 새 프로젝트 생성
forte add page <path>         # 페이지 추가
forte add action <name>       # 액션 추가
forte dev                     # 개발 서버 (watch + codegen)
forte build                   # 프로덕션 빌드
```

---

## 1단계: 프로젝트 구조 리팩토링

현재 `forte/src/main.rs`에 SSR 서버 로직이 있습니다.
CLI와 서버를 분리합니다.

### 변경 후 구조

```
forte/
├── Cargo.toml
├── src/
│   ├── main.rs              # CLI 진입점
│   ├── cli/
│   │   ├── mod.rs
│   │   ├── init.rs          # forte init
│   │   ├── add.rs           # forte add
│   │   ├── dev.rs           # forte dev
│   │   └── build.rs         # forte build
│   ├── codegen/
│   │   ├── mod.rs
│   │   ├── backend_routes.rs    # route_generated.rs 생성
│   │   └── frontend_routes.rs   # 프론트엔드 라우터 생성
│   ├── server/
│   │   └── mod.rs           # 현재 main.rs의 SSR 서버 로직
│   ├── watcher.rs           # 파일 변경 감지
│   └── templates/           # 내장 템플릿
└── templates/               # 프로젝트/페이지 템플릿 파일
```

---

## 2단계: `forte dev` 구현

개발 서버 + 코드 생성 + watch 모드

### 실행 흐름

```
forte dev
    │
    ├─1. 초기 코드 생성
    │   ├─ forte-rs-to-ts 실행 → .props.ts 생성
    │   ├─ backend routes 생성 → route_generated.rs
    │   └─ frontend routes 생성 → routes.generated.ts
    │
    ├─2. 초기 빌드
    │   ├─ cargo build --target wasm32-wasip2 (백엔드)
    │   └─ npm run build (프론트엔드)
    │
    ├─3. 서버 시작
    │   └─ http://localhost:3000
    │
    └─4. Watch 모드
        ├─ rs/src/pages/** 변경 → 백엔드 재빌드 + codegen
        └─ fe/src/pages/** 변경 → 프론트엔드 재빌드
```

### 코드 생성 상세

#### 2-1. Props 타입 생성 (기존 도구 활용)

`forte-rs-to-ts` 호출:
```rust
Command::new("forte-rs-to-ts")
    .arg(&project_rs_dir)
    .status()
```

#### 2-2. 백엔드 라우트 생성

현재 `rs/build.rs` 로직을 CLI로 이동.
`build.rs`는 단순히 CLI를 호출하거나, CLI가 직접 생성.

생성 파일: `rs/src/route_generated.rs`

#### 2-3. 프론트엔드 라우터 생성

현재 `fe/src/server.ts`의 하드코딩된 라우팅을 자동 생성.

생성 파일: `fe/src/routes.generated.ts`

```typescript
// Auto-generated by forte CLI

import type { ComponentType } from 'react';

export interface Route {
    pattern: RegExp;
    params: string[];
    load: () => Promise<{ default: ComponentType<any> }>;
}

export const routes: Route[] = [
    {
        pattern: /^\/$/,
        params: [],
        load: () => import('./pages/index/page'),
    },
    {
        pattern: /^\/product\/([^/]+)$/,
        params: ['id'],
        load: () => import('./pages/product/[id]/page'),
    },
];
```

`server.ts`는 이를 import하여 라우팅:

```typescript
import { routes } from './routes.generated';

export async function handler(request: Request): Promise<Response> {
    const url = new URL(request.url);

    for (const route of routes) {
        const match = url.pathname.match(route.pattern);
        if (match) {
            const params = Object.fromEntries(
                route.params.map((name, i) => [name, match[i + 1]])
            );
            const { default: Page } = await route.load();
            // ... render
        }
    }
}
```

---

## 3단계: `forte init` 구현

### 명령어

```bash
forte init my-app
cd my-app
```

### 생성되는 구조

```
my-app/
├── Forte.toml
├── rs/
│   ├── Cargo.toml
│   ├── .cargo/config.toml
│   └── src/
│       ├── lib.rs
│       └── pages/
│           └── index/
│               └── mod.rs
└── fe/
    ├── package.json
    ├── tsconfig.json
    ├── rolldown.config.ts
    └── src/
        ├── server.ts
        └── pages/
            └── index/
                └── page.tsx
```

### 템플릿 내장

`include_str!` 또는 `rust-embed`로 템플릿 파일 내장:

```rust
static CARGO_TOML_TEMPLATE: &str = include_str!("../templates/rs/Cargo.toml.tmpl");
static PAGE_MOD_TEMPLATE: &str = include_str!("../templates/rs/page.mod.rs.tmpl");
// ...
```

### 변수 치환

간단한 템플릿 변수 치환:
- `{{project_name}}` → 프로젝트 이름
- `{{page_name}}` → 페이지 이름

---

## 4단계: `forte add page` 구현

### 명령어

```bash
forte add page product/[id]
forte add page user/settings
```

### 동작

1. 경로 파싱
   - `product/[id]` → 정적: `product`, 동적: `id`

2. 백엔드 파일 생성
   - `rs/src/pages/product/[id]/mod.rs`

3. 프론트엔드 파일 생성
   - `fe/src/pages/product/[id]/page.tsx`

4. 코드 재생성
   - `route_generated.rs` 업데이트
   - `routes.generated.ts` 업데이트
   - `.props.ts` 생성

### 템플릿

**rs/src/pages/{path}/mod.rs:**
```rust
use serde::Serialize;

#[derive(Serialize)]
pub enum Props {
    Ok {
        // TODO: Add your props here
    },
}

// Infallible - 에러는 Props variant로 처리
pub async fn handler(
    _headers: std::collections::HashMap<String, String>,
    {{#params}}
    {{name}}: {{type}},
    {{/params}}
) -> Props {
    Props::Ok {}
}
```

**fe/src/pages/{path}/page.tsx:**
```tsx
import type { Props } from './.props';

export default function Page(props: Props) {
    if (props.t !== 'Ok') {
        return <div>Error</div>;
    }

    return (
        <div>
            <h1>{{page_name}}</h1>
            {/* TODO: Implement your page */}
        </div>
    );
}
```

---

## 5단계: `forte build` 구현

### 명령어

```bash
forte build
```

### 출력

```
dist/
├── backend.wasm         # 또는 backend.cwasm (사전 컴파일)
├── frontend/
│   └── server.js        # SSR 번들
└── static/              # 정적 에셋
```

### 빌드 단계

1. **코드 생성** (dev와 동일)

2. **백엔드 빌드**
   ```bash
   cargo build --release --target wasm32-wasip2
   ```

3. **CWASM 사전 컴파일** (선택적)
   ```bash
   wasmtime compile backend.wasm -o backend.cwasm
   ```

4. **프론트엔드 빌드**
   ```bash
   npm run build
   ```

5. **정적 에셋 복사**
   - `fe/public/` → `dist/static/`
   - 에셋 해싱 (선택적)

---

## 6단계: Watch 모드 + 핫 스왑

### 의존성

```toml
notify = "6"  # 파일 시스템 감시
```

### 감시 대상

| 경로 | 변경 시 동작 |
|------|-------------|
| `rs/src/pages/**/*.rs` | Props codegen + 백엔드 재빌드 + WASM 핫 스왑 |
| `rs/src/actions/**/*.rs` | Action codegen + 백엔드 재빌드 + WASM 핫 스왑 |
| `fe/src/pages/**/*.tsx` | 프론트엔드 재빌드 + JS 핫 스왑 |
| `fe/public/**` | 정적 에셋 변경 알림 |
| `Forte.toml` | 전체 재시작 |

### 핫 스왑 (서버 재시작 없음)

**백엔드 WASM:**
```
파일 변경 → cargo build → fn0 캐시 무효화 → 다음 요청에서 새 WASM 로드
```

**SSR JS:**
```
파일 변경 → npm run build → fn0 캐시 무효화 → 다음 요청에서 새 JS 로드
```

**클라이언트 (1차: LiveReload):**
```
파일 변경 → 브라우저에 새로고침 신호
```

### 디바운싱

빠른 연속 변경 시 재빌드 지연:
```rust
let debounce_duration = Duration::from_millis(100);
```

---

## E2E 테스트 전략

### 원칙

- **모든 명령어는 E2E 테스트로 검증**
- 수동 테스트 금지, 코드로 자동화
- `forte init`으로 생성한 프로젝트를 다른 명령어 테스트에 사용

### 테스트 구조

```
forte/
├── tests/
│   └── e2e/
│       ├── mod.rs
│       ├── init_test.rs      # forte init 테스트
│       ├── dev_test.rs       # forte dev 테스트
│       ├── add_test.rs       # forte add 테스트
│       └── build_test.rs     # forte build 테스트
```

### 테스트 의존성

```toml
[dev-dependencies]
assert_cmd = "2"      # CLI 실행 및 검증
predicates = "3"      # 출력 검증
tempfile = "3"        # 임시 디렉토리
reqwest = { version = "0.12", features = ["blocking"] }  # HTTP 요청
```

### 테스트 시나리오

**`forte init` 테스트:**
```rust
#[test]
fn test_init_creates_project_structure() {
    let temp = tempfile::tempdir().unwrap();

    Command::cargo_bin("forte").unwrap()
        .args(["init", "my-app"])
        .current_dir(&temp)
        .assert()
        .success();

    // 디렉토리 구조 검증
    assert!(temp.path().join("my-app/Forte.toml").exists());
    assert!(temp.path().join("my-app/rs/Cargo.toml").exists());
    assert!(temp.path().join("my-app/fe/package.json").exists());
}
```

**`forte dev` 테스트:**
```rust
#[tokio::test]
async fn test_dev_server_responds() {
    let temp = tempfile::tempdir().unwrap();

    // 1. forte init으로 프로젝트 생성
    Command::cargo_bin("forte").unwrap()
        .args(["init", "test-app"])
        .current_dir(&temp)
        .assert()
        .success();

    // 2. forte dev 백그라운드 실행
    let mut child = Command::cargo_bin("forte").unwrap()
        .args(["dev"])
        .current_dir(temp.path().join("test-app"))
        .spawn()
        .unwrap();

    // 3. 서버 시작 대기 후 HTTP 요청
    tokio::time::sleep(Duration::from_secs(10)).await;
    let resp = reqwest::get("http://127.0.0.1:3000").await.unwrap();
    assert!(resp.status().is_success());

    // 4. 정리
    child.kill().unwrap();
}
```

---

## 구현 순서

### 원칙

- **테스트 코드 먼저 작성, 구현은 그 다음**
- 각 단계는 E2E 테스트 통과로 완료 판정

### 1차 (MVP)

| 순서 | 작업 | 테스트 검증 항목 |
|------|------|-----------------|
| 1 | 프로젝트 구조 리팩토링 ✅ | - |
| 2 | `forte init` | 디렉토리 구조, 필수 파일 생성 |
| 3 | `forte dev` E2E 테스트 | init → dev → HTTP 200 응답 |
| 4 | 프론트엔드 라우터 자동 생성 | routes.generated.ts 파일 검증 |
| 5 | `forte add page` | 페이지 파일 생성, codegen 실행 |
| 6 | Watch 모드 + 핫 스왑 | 파일 변경 → 재빌드 → 응답 변경 |
| 7 | `forte add action` | Action 파일 생성, 타입 생성 |
| 8 | 정적 에셋 서빙 | /static/* 경로 응답 |
| 9 | `forte build` | dist/ 디렉토리 생성, 파일 검증 |

### 2차 (향후)

| 작업 | 테스트 검증 항목 |
|------|-----------------|
| 클라이언트 HMR | WebSocket 연결, 모듈 교체 |
| 프로덕션 에셋 해싱 | 해시 포함 파일명, manifest |
| Hydration 지원 | 클라이언트 JS 실행 검증 |

---

## 의존성

### CLI

```toml
[dependencies]
clap = { version = "4", features = ["derive"] }
notify = "6"
tokio = { version = "1", features = ["full"] }
serde = { version = "1", features = ["derive"] }
toml = "0.8"
```

### 기존 활용

- `forte-rs-to-ts`: Props 타입 생성 (외부 바이너리로 호출)
- `fn0`: WASM/JS 실행 (라이브러리로 의존)
- `forte-json`: JSON 직렬화 (백엔드에서 사용)

---

## Forte.toml 설정

```toml
[project]
name = "my-app"

[dev]
port = 3000

[build]
# CWASM 사전 컴파일 여부
precompile_wasm = false

[paths]
backend = "rs"
frontend = "fe"
```

---

## 결정된 사항

### 1. 코드 생성 역할 분담

| 생성 대상 | 담당 |
|-----------|------|
| 백엔드 라우트 (`route_generated.rs`) | `build.rs` 유지 |
| Props/Action 타입, 프론트엔드 라우터 | CLI |

- 백엔드 개발자: `cargo build`만으로 독립 작업 가능
- CLI는 `forte-rs-to-ts`를 호출하여 타입 생성

### 2. 핫 스왑 + HMR

**1차 구현:**
- 백엔드 WASM 핫 스왑 (서버 재시작 없음)
- SSR JS 핫 스왑 (서버 재시작 없음)
- 클라이언트: LiveReload (브라우저 새로고침)

**TODO (향후 필수):**
- 클라이언트 HMR (React Fast Refresh)
- Vite 통합 vs 자체 구현 → 추후 결정

### 3. Action 구현 방식

**Astro Actions 스타일 벤치마크**

백엔드 구조:
```
rs/src/
├── pages/
│   └── index/mod.rs
└── actions/
    └── user/
        └── login.rs      # → actions.user.login()
```

**actions/user/login.rs:**
```rust
use serde::{Serialize, Deserialize};

#[derive(Deserialize)]
pub struct Params {
    pub email: String,
    pub password: String,
}

#[derive(Serialize)]
pub enum Response {
    Ok { token: String },
    Error { message: String },
}

// Infallible - 에러는 Response variant로 처리
pub async fn handler(request: Request) -> Response {
    Response::Ok { token: "...".to_string() }
}
```

**프론트엔드 사용:**
```typescript
import { actions } from 'forte:actions';

const result = await actions.user.login({ email, password });
if (result.t === 'Ok') {
    console.log(result.v.token);
}
```

- 중첩 경로 지원: `actions/user/login.rs` → `actions.user.login()`
- `forte:actions` import 방식: Astro 스타일 (구현 시 상세 결정)

### 4. 정적 에셋 처리

- 디렉토리: `fe/public/`
- 개발 환경: `forte dev`가 직접 서빙
- 프로덕션 빌드:
  - 에셋 해싱 적용 (캐시 무효화)
  - CDN 경로 지원 필수
